{"ast":null,"code":"import SturdyWebSocket from 'sturdy-websocket';\nimport CryptoEs from 'crypto-es';\nconst networks = {\n  bitcoin: {\n    '1': 'main',\n    '2': 'testnet'\n  },\n  ethereum: {\n    '1': 'main',\n    '3': 'ropsten',\n    '4': 'rinkeby',\n    '5': 'goerli',\n    '42': 'kovan',\n    '100': 'xdai'\n  }\n};\n\nfunction createEmitter() {\n  return {\n    listeners: {},\n    on: function (eventCode, listener) {\n      // check if valid eventCode\n      switch (eventCode) {\n        case 'txSent':\n        case 'txPool':\n        case 'txConfirmed':\n        case 'txSpeedUp':\n        case 'txCancel':\n        case 'txFailed':\n        case 'all':\n          break;\n\n        default:\n          throw new Error(`${eventCode} is not a valid event code, for a list of valid event codes see: https://github.com/blocknative/sdk`);\n      } // check that listener is a function\n\n\n      if (typeof listener !== 'function') {\n        throw new Error('Listener must be a function');\n      } // add listener for the eventCode\n\n\n      this.listeners[eventCode] = listener;\n    },\n    emit: function (state) {\n      if (this.listeners[state.eventCode]) {\n        return this.listeners[state.eventCode](state);\n      }\n\n      if (this.listeners.all) {\n        return this.listeners.all(state);\n      }\n    }\n  };\n}\n\nfunction networkName(blockchain, id) {\n  return networks[blockchain][id];\n}\n\nfunction serverEcho(eventCode) {\n  switch (eventCode) {\n    case 'txRequest':\n    case 'nsfFail':\n    case 'txRepeat':\n    case 'txAwaitingApproval':\n    case 'txConfirmReminder':\n    case 'txSendFail':\n    case 'txError':\n    case 'txUnderPriced':\n    case 'txSent':\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nfunction last(arr) {\n  return arr.reverse()[0];\n} // isAddress and isTxid are not meant to perform real validation,\n// just needs to work out if it is an address or a transaction id\n// the server will do more thorough validation\n\n\nfunction isAddress(blockchain, addressOrHash) {\n  switch (blockchain) {\n    case 'ethereum':\n      return addressOrHash.length === 42;\n\n    case 'bitcoin':\n      return addressOrHash.length !== 64;\n\n    default:\n      return false;\n  }\n}\n\nfunction isTxid(blockchain, addressOrHash) {\n  switch (blockchain) {\n    case 'ethereum':\n      return addressOrHash.length === 66;\n\n    case 'bitcoin':\n      return addressOrHash.length === 64;\n\n    default:\n      return false;\n  }\n}\n\nfunction transaction(hash, id) {\n  if (this._destroyed) throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.'); // create startTime for transaction\n\n  const startTime = Date.now(); // create emitter for transaction\n\n  const emitter = createEmitter(); // create eventCode for transaction\n\n  const eventCode = 'txSent'; // put in queue\n\n  this._watchedTransactions.push({\n    hash,\n    emitter\n  });\n\n  const transaction = {\n    [this._system === 'ethereum' ? 'hash' : 'txid']: hash,\n    id: id || hash,\n    startTime,\n    status: 'sent'\n  };\n  const newState = { ...transaction,\n    eventCode\n  }; // logEvent to server\n\n  this._sendMessage({\n    eventCode,\n    categoryCode: 'activeTransaction',\n    transaction\n  });\n\n  const transactionObj = {\n    details: transaction,\n    emitter\n  };\n\n  function emitState() {\n    const emitterResult = emitter.emit(newState);\n\n    this._transactionHandlers.forEach(handler => handler({\n      transaction: newState,\n      emitterResult\n    }));\n  } // emit after delay to allow for listener to be registered\n\n\n  setTimeout(emitState.bind(this), 5);\n  return transactionObj;\n}\n\nfunction account(address) {\n  if (this._destroyed) throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.'); // lowercase the address if Ethereum\n\n  address = this._system === 'ethereum' ? address.toLowerCase() : address; // create emitter for transaction\n\n  const emitter = createEmitter(); // create eventCode for transaction\n\n  const eventCode = 'watch';\n\n  const existingAddressWatcher = this._watchedAccounts.find(ac => ac.address === address);\n\n  if (existingAddressWatcher) {\n    // add to existing emitters array\n    existingAddressWatcher.emitters.push(emitter);\n  } else {\n    // put in accounts queue\n    this._watchedAccounts.push({\n      address,\n      emitters: [emitter]\n    });\n  } // logEvent to server\n\n\n  this._sendMessage({\n    eventCode,\n    categoryCode: 'accountAddress',\n    account: {\n      address\n    }\n  });\n\n  return {\n    emitter,\n    details: {\n      address\n    }\n  };\n}\n\nfunction event(eventObj) {\n  if (this._destroyed) throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.');\n\n  this._sendMessage(eventObj);\n}\n\nfunction unsubscribe(addressOrHash) {\n  if (this._destroyed) throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.');\n  const address = isAddress(this._system, addressOrHash);\n  const txid = isTxid(this._system, addressOrHash); // check if it is an address or a hash\n\n  if (address) {\n    const normalizedAddress = this._system === 'ethereum' ? addressOrHash.toLowerCase() : addressOrHash; // remove address from accounts\n\n    this._watchedAccounts = this._watchedAccounts.filter(ac => ac.address !== normalizedAddress); // logEvent to server\n\n    this._sendMessage({\n      categoryCode: 'accountAddress',\n      eventCode: 'unwatch',\n      account: {\n        address: normalizedAddress\n      }\n    });\n  } else if (txid) {\n    // remove transaction from transactions\n    this._watchedTransactions = this._watchedTransactions.filter(tx => tx.hash !== addressOrHash); // logEvent to server\n\n    this._sendMessage({\n      categoryCode: 'activeTransaction',\n      eventCode: 'unwatch',\n      transaction: {\n        [this._system === 'ethereum' ? 'hash' : 'txid']: addressOrHash,\n        id: addressOrHash,\n        status: 'unsubscribed'\n      }\n    });\n  } else {\n    throw new Error(`Error trying to unsubscribe ${addressOrHash}: not a valid address or transaction id/hash`);\n  }\n}\n\nvar version = \"2.1.4\";\n\nasync function sendMessage(msg) {\n  if (!this._connected) {\n    await waitForConnectionOpen.bind(this)();\n  }\n\n  this._socket.send(createEventLog.bind(this)(msg));\n}\n\nfunction waitForConnectionOpen() {\n  return new Promise(resolve => {\n    const interval = setInterval(() => {\n      if (this._connected) {\n        setTimeout(resolve, 100);\n        clearInterval(interval);\n      }\n    });\n  });\n}\n\nfunction handleMessage(msg) {\n  const {\n    status,\n    reason,\n    event,\n    connectionId\n  } = JSON.parse(msg.data);\n\n  if (connectionId) {\n    if (typeof window !== 'undefined') {\n      window.localStorage.setItem(this._storageKey, connectionId);\n    }\n\n    this._connectionId = connectionId;\n  } // handle any errors from the server\n\n\n  if (status === 'error') {\n    if (reason.includes('not a valid API key')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    }\n\n    if (reason.includes('network not supported')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    }\n\n    if (reason.includes('maximum allowed amount')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // handle bitcoin txid error\n\n\n    if (reason.includes('invalid txid')) {\n      const reason = `${event.transaction.txid} is an invalid txid`;\n\n      if (this._onerror) {\n        this._onerror({\n          message: reason,\n          transaction: event.transaction.txid\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // handle ethereum transaction hash error\n\n\n    if (reason.includes('invalid hash')) {\n      const reason = `${event.transaction.hash} is an invalid transaction hash`;\n\n      if (this._onerror) {\n        this._onerror({\n          message: reason,\n          transaction: event.transaction.hash\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // handle general address error\n\n\n    if (reason.includes('invalid address')) {\n      const reason = `${event.account.address} is an invalid address`;\n\n      if (this._onerror) {\n        this._onerror({\n          message: reason,\n          account: event.account.address\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // handle bitcoin specific address error\n\n\n    if (reason.includes('not a valid Bitcoin')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason,\n          account: event.account.address\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // handle ethereum specific address error\n\n\n    if (reason.includes('not a valid Ethereum')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason,\n          account: event.account.address\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // throw error that comes back from the server without formatting the message\n\n\n    if (this._onerror) {\n      this._onerror({\n        message: reason\n      });\n\n      return;\n    } else {\n      throw new Error(reason);\n    }\n  }\n\n  if (event && event.transaction) {\n    const {\n      transaction,\n      eventCode,\n      contractCall\n    } = event; // flatten in to one object\n\n    const newState = this._system === 'ethereum' ? { ...transaction,\n      eventCode,\n      contractCall\n    } : { ...transaction,\n      eventCode\n    }; // ignore server echo and unsubscribe messages\n\n    if (serverEcho(eventCode) || transaction.status === 'unsubscribed') {\n      return;\n    } // handle change of hash in speedup and cancel events\n\n\n    if (eventCode === 'txSpeedUp' || eventCode === 'txCancel') {\n      this._watchedTransactions = this._watchedTransactions.map(tx => {\n        if (tx.hash === transaction.originalHash) {\n          // reassign hash parameter in transaction queue to new hash or txid\n          tx.hash = transaction.hash || transaction.txid;\n        }\n\n        return tx;\n      });\n    }\n\n    const watchedAddress = transaction.watchedAddress && this._system === 'ethereum' ? transaction.watchedAddress.toLowerCase() : transaction.watchedAddress;\n\n    if (watchedAddress) {\n      const accountObj = this._watchedAccounts.find(ac => ac.address === watchedAddress);\n\n      const emitterResult = accountObj ? last(accountObj.emitters.map(emitter => emitter.emit(newState))) : false;\n\n      this._transactionHandlers.forEach(handler => handler({\n        transaction: newState,\n        emitterResult\n      }));\n    } else {\n      const transactionObj = this._watchedTransactions.find(tx => tx.hash === transaction.hash || transaction.txid);\n\n      const emitterResult = transactionObj && transactionObj.emitter.emit(newState);\n\n      this._transactionHandlers.forEach(handler => handler({\n        transaction: newState,\n        emitterResult\n      }));\n    }\n  }\n}\n\nfunction createEventLog(msg) {\n  return JSON.stringify({\n    timeStamp: new Date(),\n    dappId: this._dappId,\n    version,\n    blockchain: {\n      system: this._system,\n      network: networkName(this._system, this._networkId) || 'local'\n    },\n    ...msg\n  });\n}\n\nfunction validateType(options) {\n  const {\n    name,\n    value,\n    type,\n    optional,\n    customValidation\n  } = options;\n\n  if (!optional && typeof value === 'undefined') {\n    throw new Error(`\"${name}\" is required`);\n  }\n\n  if (typeof value !== 'undefined' && (type === 'array' ? Array.isArray(type) : typeof value !== type)) {\n    throw new Error(`\"${name}\" must be of type: ${type}, received type: ${typeof value} from value: ${value}`);\n  }\n\n  if (typeof value !== 'undefined' && customValidation && !customValidation(value)) {\n    throw new Error(`\"${value}\" is not a valid \"${name}\"`);\n  }\n}\n\nfunction validateOptions(options) {\n  validateType({\n    name: 'sdk options',\n    value: options,\n    type: 'object'\n  });\n  const {\n    dappId,\n    system,\n    name,\n    networkId,\n    transactionHandlers,\n    apiUrl,\n    ws,\n    onopen,\n    ondown,\n    onreopen,\n    onerror,\n    onclose,\n    ...otherParams\n  } = options;\n  invalidParams(otherParams, ['dappId', 'system', 'name', 'networkId', 'transactionHandlers', 'apiUrl', 'ws', 'onopen', 'ondown', 'onreopen', 'onerror', 'onclose'], 'Initialization Options');\n  validateType({\n    name: 'dappId',\n    value: dappId,\n    type: 'string'\n  });\n  validateType({\n    name: 'system',\n    value: system,\n    type: 'string',\n    optional: true,\n    customValidation: validSystem\n  });\n  validateType({\n    name: 'name',\n    value: name,\n    type: 'string',\n    optional: true\n  });\n  validateType({\n    name: 'networkId',\n    value: networkId,\n    type: 'number'\n  });\n  validateType({\n    name: 'transactionHandler',\n    value: transactionHandlers,\n    type: 'array',\n    optional: true\n  });\n\n  if (transactionHandlers) {\n    transactionHandlers.forEach(handler => validateType({\n      name: 'transactionHandler',\n      value: handler,\n      type: 'function'\n    }));\n  }\n\n  validateType({\n    name: 'apiUrl',\n    value: apiUrl,\n    type: 'string',\n    optional: true\n  });\n  validateType({\n    name: 'ws',\n    value: ws,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'onopen',\n    value: onopen,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'ondown',\n    value: ondown,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'onreopen',\n    value: onreopen,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'onerror',\n    value: onerror,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'onclose',\n    value: onclose,\n    type: 'function',\n    optional: true\n  });\n}\n\nfunction validSystem(system) {\n  return !!networks[system];\n}\n\nfunction invalidParams(params, validParams, functionName) {\n  const invalid = Object.keys(params);\n\n  if (invalid.length > 0) {\n    throw new Error(`${invalid[0]} is not a valid parameter for ${functionName}, must be one of the following valid parameters: ${validParams.join(', ')}`);\n  }\n}\n\nconst DEFAULT_NAME = 'unknown';\nconst DEFAULT_SYSTEM = 'ethereum';\n\nclass Blocknative {\n  constructor(options) {\n    validateOptions(options);\n    const {\n      dappId,\n      system = DEFAULT_SYSTEM,\n      name = DEFAULT_NAME,\n      networkId,\n      transactionHandlers = [],\n      apiUrl,\n      ws,\n      onopen,\n      ondown,\n      onreopen,\n      onerror,\n      onclose\n    } = options;\n    const socket = new SturdyWebSocket(apiUrl || 'wss://api.blocknative.com/v0', ws ? {\n      wsConstructor: ws\n    } : {});\n    socket.onopen = onOpen.bind(this, onopen);\n    socket.ondown = onDown.bind(this, ondown);\n    socket.onreopen = onReopen.bind(this, onreopen);\n    socket.onmessage = handleMessage.bind(this);\n\n    socket.onerror = error => onerror && onerror({\n      message: 'There was a WebSocket error',\n      error\n    });\n\n    socket.onclose = () => {\n      this._pingTimeout && clearInterval(this._pingTimeout);\n      onclose && onclose();\n    };\n\n    const storageKey = CryptoEs.SHA1(`${dappId} - ${name}`).toString();\n    const storedConnectionId = typeof window !== 'undefined' && window.localStorage.getItem(storageKey);\n    this._storageKey = storageKey;\n    this._connectionId = storedConnectionId || undefined;\n    this._dappId = dappId;\n    this._system = system;\n    this._networkId = networkId;\n    this._transactionHandlers = transactionHandlers;\n    this._socket = socket;\n    this._connected = false;\n    this._sendMessage = sendMessage.bind(this);\n    this._watchedTransactions = [];\n    this._watchedAccounts = [];\n    this._pingTimeout = undefined;\n    this._destroyed = false;\n    this._onerror = onerror;\n\n    if (this._socket.ws.on) {\n      this._heartbeat = () => {\n        this._pingTimeout && clearTimeout(this._pingTimeout);\n        this._pingTimeout = setTimeout(() => {\n          // terminate connection if we haven't heard the server ping after server timeout plus conservative latency delay\n          // Sturdy Websocket will handle the new connection logic\n          this._socket.ws.terminate();\n        }, 30000 + 1000);\n      };\n\n      this._socket.ws.on('ping', () => {\n        this._heartbeat && this._heartbeat();\n      });\n    } // public API\n\n\n    this.transaction = transaction.bind(this);\n    this.account = account.bind(this);\n    this.event = event.bind(this);\n    this.unsubscribe = unsubscribe.bind(this);\n\n    this.destroy = () => {\n      this._socket.close();\n\n      this._destroyed = true; // call onclose manually here as SturdyWebSocket doesn't currently work as expected\n      // https://github.com/dphilipson/sturdy-websocket/issues/5\n\n      this._socket.onclose();\n    };\n  }\n\n}\n\nfunction onOpen(handler) {\n  this._connected = true;\n\n  this._sendMessage({\n    categoryCode: 'initialize',\n    eventCode: 'checkDappId',\n    connectionId: this._connectionId\n  });\n\n  this._heartbeat && this._heartbeat();\n  handler && handler();\n}\n\nfunction onDown(handler, closeEvent) {\n  this._connected = false;\n\n  if (handler) {\n    handler(closeEvent);\n  }\n\n  this._pingTimeout && clearTimeout(this._pingTimeout);\n}\n\nfunction onReopen(handler) {\n  this._connected = true;\n\n  this._sendMessage({\n    categoryCode: 'initialize',\n    eventCode: 'checkDappId',\n    connectionId: this._connectionId\n  }); // re-register all accounts to be watched by server upon\n  // re-connection as they don't get transferred over automatically\n  // to the new connection like tx hashes do\n\n\n  this._watchedAccounts.forEach(account => {\n    this._sendMessage({\n      eventCode: 'accountAddress',\n      categoryCode: 'watch',\n      account: {\n        address: account.address\n      }\n    });\n  });\n\n  if (handler) {\n    handler();\n  }\n\n  if (this._socket.ws.on) {\n    // need to re-register ping event since new connection\n    this._socket.ws.on('ping', () => {\n      this._heartbeat && this._heartbeat();\n    });\n\n    this._heartbeat();\n  }\n}\n\nexport default Blocknative;","map":{"version":3,"sources":["/Users/mdelgado/Documents/source/FinTech/scaffold-eth/node_modules/bnc-sdk/dist/esm/index.js"],"names":["SturdyWebSocket","CryptoEs","networks","bitcoin","ethereum","createEmitter","listeners","on","eventCode","listener","Error","emit","state","all","networkName","blockchain","id","serverEcho","last","arr","reverse","isAddress","addressOrHash","length","isTxid","transaction","hash","_destroyed","startTime","Date","now","emitter","_watchedTransactions","push","_system","status","newState","_sendMessage","categoryCode","transactionObj","details","emitState","emitterResult","_transactionHandlers","forEach","handler","setTimeout","bind","account","address","toLowerCase","existingAddressWatcher","_watchedAccounts","find","ac","emitters","event","eventObj","unsubscribe","txid","normalizedAddress","filter","tx","version","sendMessage","msg","_connected","waitForConnectionOpen","_socket","send","createEventLog","Promise","resolve","interval","setInterval","clearInterval","handleMessage","reason","connectionId","JSON","parse","data","window","localStorage","setItem","_storageKey","_connectionId","includes","_onerror","message","contractCall","map","originalHash","watchedAddress","accountObj","stringify","timeStamp","dappId","_dappId","system","network","_networkId","validateType","options","name","value","type","optional","customValidation","Array","isArray","validateOptions","networkId","transactionHandlers","apiUrl","ws","onopen","ondown","onreopen","onerror","onclose","otherParams","invalidParams","validSystem","params","validParams","functionName","invalid","Object","keys","join","DEFAULT_NAME","DEFAULT_SYSTEM","Blocknative","constructor","socket","wsConstructor","onOpen","onDown","onReopen","onmessage","error","_pingTimeout","storageKey","SHA1","toString","storedConnectionId","getItem","undefined","_heartbeat","clearTimeout","terminate","destroy","close","closeEvent"],"mappings":"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","sourcesContent":["import SturdyWebSocket from 'sturdy-websocket';\nimport CryptoEs from 'crypto-es';\nconst networks = {\n  bitcoin: {\n    '1': 'main',\n    '2': 'testnet'\n  },\n  ethereum: {\n    '1': 'main',\n    '3': 'ropsten',\n    '4': 'rinkeby',\n    '5': 'goerli',\n    '42': 'kovan',\n    '100': 'xdai'\n  }\n};\n\nfunction createEmitter() {\n  return {\n    listeners: {},\n    on: function (eventCode, listener) {\n      // check if valid eventCode\n      switch (eventCode) {\n        case 'txSent':\n        case 'txPool':\n        case 'txConfirmed':\n        case 'txSpeedUp':\n        case 'txCancel':\n        case 'txFailed':\n        case 'all':\n          break;\n\n        default:\n          throw new Error(`${eventCode} is not a valid event code, for a list of valid event codes see: https://github.com/blocknative/sdk`);\n      } // check that listener is a function\n\n\n      if (typeof listener !== 'function') {\n        throw new Error('Listener must be a function');\n      } // add listener for the eventCode\n\n\n      this.listeners[eventCode] = listener;\n    },\n    emit: function (state) {\n      if (this.listeners[state.eventCode]) {\n        return this.listeners[state.eventCode](state);\n      }\n\n      if (this.listeners.all) {\n        return this.listeners.all(state);\n      }\n    }\n  };\n}\n\nfunction networkName(blockchain, id) {\n  return networks[blockchain][id];\n}\n\nfunction serverEcho(eventCode) {\n  switch (eventCode) {\n    case 'txRequest':\n    case 'nsfFail':\n    case 'txRepeat':\n    case 'txAwaitingApproval':\n    case 'txConfirmReminder':\n    case 'txSendFail':\n    case 'txError':\n    case 'txUnderPriced':\n    case 'txSent':\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nfunction last(arr) {\n  return arr.reverse()[0];\n} // isAddress and isTxid are not meant to perform real validation,\n// just needs to work out if it is an address or a transaction id\n// the server will do more thorough validation\n\n\nfunction isAddress(blockchain, addressOrHash) {\n  switch (blockchain) {\n    case 'ethereum':\n      return addressOrHash.length === 42;\n\n    case 'bitcoin':\n      return addressOrHash.length !== 64;\n\n    default:\n      return false;\n  }\n}\n\nfunction isTxid(blockchain, addressOrHash) {\n  switch (blockchain) {\n    case 'ethereum':\n      return addressOrHash.length === 66;\n\n    case 'bitcoin':\n      return addressOrHash.length === 64;\n\n    default:\n      return false;\n  }\n}\n\nfunction transaction(hash, id) {\n  if (this._destroyed) throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.'); // create startTime for transaction\n\n  const startTime = Date.now(); // create emitter for transaction\n\n  const emitter = createEmitter(); // create eventCode for transaction\n\n  const eventCode = 'txSent'; // put in queue\n\n  this._watchedTransactions.push({\n    hash,\n    emitter\n  });\n\n  const transaction = {\n    [this._system === 'ethereum' ? 'hash' : 'txid']: hash,\n    id: id || hash,\n    startTime,\n    status: 'sent'\n  };\n  const newState = { ...transaction,\n    eventCode\n  }; // logEvent to server\n\n  this._sendMessage({\n    eventCode,\n    categoryCode: 'activeTransaction',\n    transaction\n  });\n\n  const transactionObj = {\n    details: transaction,\n    emitter\n  };\n\n  function emitState() {\n    const emitterResult = emitter.emit(newState);\n\n    this._transactionHandlers.forEach(handler => handler({\n      transaction: newState,\n      emitterResult\n    }));\n  } // emit after delay to allow for listener to be registered\n\n\n  setTimeout(emitState.bind(this), 5);\n  return transactionObj;\n}\n\nfunction account(address) {\n  if (this._destroyed) throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.'); // lowercase the address if Ethereum\n\n  address = this._system === 'ethereum' ? address.toLowerCase() : address; // create emitter for transaction\n\n  const emitter = createEmitter(); // create eventCode for transaction\n\n  const eventCode = 'watch';\n\n  const existingAddressWatcher = this._watchedAccounts.find(ac => ac.address === address);\n\n  if (existingAddressWatcher) {\n    // add to existing emitters array\n    existingAddressWatcher.emitters.push(emitter);\n  } else {\n    // put in accounts queue\n    this._watchedAccounts.push({\n      address,\n      emitters: [emitter]\n    });\n  } // logEvent to server\n\n\n  this._sendMessage({\n    eventCode,\n    categoryCode: 'accountAddress',\n    account: {\n      address\n    }\n  });\n\n  return {\n    emitter,\n    details: {\n      address\n    }\n  };\n}\n\nfunction event(eventObj) {\n  if (this._destroyed) throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.');\n\n  this._sendMessage(eventObj);\n}\n\nfunction unsubscribe(addressOrHash) {\n  if (this._destroyed) throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.');\n  const address = isAddress(this._system, addressOrHash);\n  const txid = isTxid(this._system, addressOrHash); // check if it is an address or a hash\n\n  if (address) {\n    const normalizedAddress = this._system === 'ethereum' ? addressOrHash.toLowerCase() : addressOrHash; // remove address from accounts\n\n    this._watchedAccounts = this._watchedAccounts.filter(ac => ac.address !== normalizedAddress); // logEvent to server\n\n    this._sendMessage({\n      categoryCode: 'accountAddress',\n      eventCode: 'unwatch',\n      account: {\n        address: normalizedAddress\n      }\n    });\n  } else if (txid) {\n    // remove transaction from transactions\n    this._watchedTransactions = this._watchedTransactions.filter(tx => tx.hash !== addressOrHash); // logEvent to server\n\n    this._sendMessage({\n      categoryCode: 'activeTransaction',\n      eventCode: 'unwatch',\n      transaction: {\n        [this._system === 'ethereum' ? 'hash' : 'txid']: addressOrHash,\n        id: addressOrHash,\n        status: 'unsubscribed'\n      }\n    });\n  } else {\n    throw new Error(`Error trying to unsubscribe ${addressOrHash}: not a valid address or transaction id/hash`);\n  }\n}\n\nvar version = \"2.1.4\";\n\nasync function sendMessage(msg) {\n  if (!this._connected) {\n    await waitForConnectionOpen.bind(this)();\n  }\n\n  this._socket.send(createEventLog.bind(this)(msg));\n}\n\nfunction waitForConnectionOpen() {\n  return new Promise(resolve => {\n    const interval = setInterval(() => {\n      if (this._connected) {\n        setTimeout(resolve, 100);\n        clearInterval(interval);\n      }\n    });\n  });\n}\n\nfunction handleMessage(msg) {\n  const {\n    status,\n    reason,\n    event,\n    connectionId\n  } = JSON.parse(msg.data);\n\n  if (connectionId) {\n    if (typeof window !== 'undefined') {\n      window.localStorage.setItem(this._storageKey, connectionId);\n    }\n\n    this._connectionId = connectionId;\n  } // handle any errors from the server\n\n\n  if (status === 'error') {\n    if (reason.includes('not a valid API key')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    }\n\n    if (reason.includes('network not supported')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    }\n\n    if (reason.includes('maximum allowed amount')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // handle bitcoin txid error\n\n\n    if (reason.includes('invalid txid')) {\n      const reason = `${event.transaction.txid} is an invalid txid`;\n\n      if (this._onerror) {\n        this._onerror({\n          message: reason,\n          transaction: event.transaction.txid\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // handle ethereum transaction hash error\n\n\n    if (reason.includes('invalid hash')) {\n      const reason = `${event.transaction.hash} is an invalid transaction hash`;\n\n      if (this._onerror) {\n        this._onerror({\n          message: reason,\n          transaction: event.transaction.hash\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // handle general address error\n\n\n    if (reason.includes('invalid address')) {\n      const reason = `${event.account.address} is an invalid address`;\n\n      if (this._onerror) {\n        this._onerror({\n          message: reason,\n          account: event.account.address\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // handle bitcoin specific address error\n\n\n    if (reason.includes('not a valid Bitcoin')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason,\n          account: event.account.address\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // handle ethereum specific address error\n\n\n    if (reason.includes('not a valid Ethereum')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason,\n          account: event.account.address\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // throw error that comes back from the server without formatting the message\n\n\n    if (this._onerror) {\n      this._onerror({\n        message: reason\n      });\n\n      return;\n    } else {\n      throw new Error(reason);\n    }\n  }\n\n  if (event && event.transaction) {\n    const {\n      transaction,\n      eventCode,\n      contractCall\n    } = event; // flatten in to one object\n\n    const newState = this._system === 'ethereum' ? { ...transaction,\n      eventCode,\n      contractCall\n    } : { ...transaction,\n      eventCode\n    }; // ignore server echo and unsubscribe messages\n\n    if (serverEcho(eventCode) || transaction.status === 'unsubscribed') {\n      return;\n    } // handle change of hash in speedup and cancel events\n\n\n    if (eventCode === 'txSpeedUp' || eventCode === 'txCancel') {\n      this._watchedTransactions = this._watchedTransactions.map(tx => {\n        if (tx.hash === transaction.originalHash) {\n          // reassign hash parameter in transaction queue to new hash or txid\n          tx.hash = transaction.hash || transaction.txid;\n        }\n\n        return tx;\n      });\n    }\n\n    const watchedAddress = transaction.watchedAddress && this._system === 'ethereum' ? transaction.watchedAddress.toLowerCase() : transaction.watchedAddress;\n\n    if (watchedAddress) {\n      const accountObj = this._watchedAccounts.find(ac => ac.address === watchedAddress);\n\n      const emitterResult = accountObj ? last(accountObj.emitters.map(emitter => emitter.emit(newState))) : false;\n\n      this._transactionHandlers.forEach(handler => handler({\n        transaction: newState,\n        emitterResult\n      }));\n    } else {\n      const transactionObj = this._watchedTransactions.find(tx => tx.hash === transaction.hash || transaction.txid);\n\n      const emitterResult = transactionObj && transactionObj.emitter.emit(newState);\n\n      this._transactionHandlers.forEach(handler => handler({\n        transaction: newState,\n        emitterResult\n      }));\n    }\n  }\n}\n\nfunction createEventLog(msg) {\n  return JSON.stringify({\n    timeStamp: new Date(),\n    dappId: this._dappId,\n    version,\n    blockchain: {\n      system: this._system,\n      network: networkName(this._system, this._networkId) || 'local'\n    },\n    ...msg\n  });\n}\n\nfunction validateType(options) {\n  const {\n    name,\n    value,\n    type,\n    optional,\n    customValidation\n  } = options;\n\n  if (!optional && typeof value === 'undefined') {\n    throw new Error(`\"${name}\" is required`);\n  }\n\n  if (typeof value !== 'undefined' && (type === 'array' ? Array.isArray(type) : typeof value !== type)) {\n    throw new Error(`\"${name}\" must be of type: ${type}, received type: ${typeof value} from value: ${value}`);\n  }\n\n  if (typeof value !== 'undefined' && customValidation && !customValidation(value)) {\n    throw new Error(`\"${value}\" is not a valid \"${name}\"`);\n  }\n}\n\nfunction validateOptions(options) {\n  validateType({\n    name: 'sdk options',\n    value: options,\n    type: 'object'\n  });\n  const {\n    dappId,\n    system,\n    name,\n    networkId,\n    transactionHandlers,\n    apiUrl,\n    ws,\n    onopen,\n    ondown,\n    onreopen,\n    onerror,\n    onclose,\n    ...otherParams\n  } = options;\n  invalidParams(otherParams, ['dappId', 'system', 'name', 'networkId', 'transactionHandlers', 'apiUrl', 'ws', 'onopen', 'ondown', 'onreopen', 'onerror', 'onclose'], 'Initialization Options');\n  validateType({\n    name: 'dappId',\n    value: dappId,\n    type: 'string'\n  });\n  validateType({\n    name: 'system',\n    value: system,\n    type: 'string',\n    optional: true,\n    customValidation: validSystem\n  });\n  validateType({\n    name: 'name',\n    value: name,\n    type: 'string',\n    optional: true\n  });\n  validateType({\n    name: 'networkId',\n    value: networkId,\n    type: 'number'\n  });\n  validateType({\n    name: 'transactionHandler',\n    value: transactionHandlers,\n    type: 'array',\n    optional: true\n  });\n\n  if (transactionHandlers) {\n    transactionHandlers.forEach(handler => validateType({\n      name: 'transactionHandler',\n      value: handler,\n      type: 'function'\n    }));\n  }\n\n  validateType({\n    name: 'apiUrl',\n    value: apiUrl,\n    type: 'string',\n    optional: true\n  });\n  validateType({\n    name: 'ws',\n    value: ws,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'onopen',\n    value: onopen,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'ondown',\n    value: ondown,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'onreopen',\n    value: onreopen,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'onerror',\n    value: onerror,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'onclose',\n    value: onclose,\n    type: 'function',\n    optional: true\n  });\n}\n\nfunction validSystem(system) {\n  return !!networks[system];\n}\n\nfunction invalidParams(params, validParams, functionName) {\n  const invalid = Object.keys(params);\n\n  if (invalid.length > 0) {\n    throw new Error(`${invalid[0]} is not a valid parameter for ${functionName}, must be one of the following valid parameters: ${validParams.join(', ')}`);\n  }\n}\n\nconst DEFAULT_NAME = 'unknown';\nconst DEFAULT_SYSTEM = 'ethereum';\n\nclass Blocknative {\n  constructor(options) {\n    validateOptions(options);\n    const {\n      dappId,\n      system = DEFAULT_SYSTEM,\n      name = DEFAULT_NAME,\n      networkId,\n      transactionHandlers = [],\n      apiUrl,\n      ws,\n      onopen,\n      ondown,\n      onreopen,\n      onerror,\n      onclose\n    } = options;\n    const socket = new SturdyWebSocket(apiUrl || 'wss://api.blocknative.com/v0', ws ? {\n      wsConstructor: ws\n    } : {});\n    socket.onopen = onOpen.bind(this, onopen);\n    socket.ondown = onDown.bind(this, ondown);\n    socket.onreopen = onReopen.bind(this, onreopen);\n    socket.onmessage = handleMessage.bind(this);\n\n    socket.onerror = error => onerror && onerror({\n      message: 'There was a WebSocket error',\n      error\n    });\n\n    socket.onclose = () => {\n      this._pingTimeout && clearInterval(this._pingTimeout);\n      onclose && onclose();\n    };\n\n    const storageKey = CryptoEs.SHA1(`${dappId} - ${name}`).toString();\n    const storedConnectionId = typeof window !== 'undefined' && window.localStorage.getItem(storageKey);\n    this._storageKey = storageKey;\n    this._connectionId = storedConnectionId || undefined;\n    this._dappId = dappId;\n    this._system = system;\n    this._networkId = networkId;\n    this._transactionHandlers = transactionHandlers;\n    this._socket = socket;\n    this._connected = false;\n    this._sendMessage = sendMessage.bind(this);\n    this._watchedTransactions = [];\n    this._watchedAccounts = [];\n    this._pingTimeout = undefined;\n    this._destroyed = false;\n    this._onerror = onerror;\n\n    if (this._socket.ws.on) {\n      this._heartbeat = () => {\n        this._pingTimeout && clearTimeout(this._pingTimeout);\n        this._pingTimeout = setTimeout(() => {\n          // terminate connection if we haven't heard the server ping after server timeout plus conservative latency delay\n          // Sturdy Websocket will handle the new connection logic\n          this._socket.ws.terminate();\n        }, 30000 + 1000);\n      };\n\n      this._socket.ws.on('ping', () => {\n        this._heartbeat && this._heartbeat();\n      });\n    } // public API\n\n\n    this.transaction = transaction.bind(this);\n    this.account = account.bind(this);\n    this.event = event.bind(this);\n    this.unsubscribe = unsubscribe.bind(this);\n\n    this.destroy = () => {\n      this._socket.close();\n\n      this._destroyed = true; // call onclose manually here as SturdyWebSocket doesn't currently work as expected\n      // https://github.com/dphilipson/sturdy-websocket/issues/5\n\n      this._socket.onclose();\n    };\n  }\n\n}\n\nfunction onOpen(handler) {\n  this._connected = true;\n\n  this._sendMessage({\n    categoryCode: 'initialize',\n    eventCode: 'checkDappId',\n    connectionId: this._connectionId\n  });\n\n  this._heartbeat && this._heartbeat();\n  handler && handler();\n}\n\nfunction onDown(handler, closeEvent) {\n  this._connected = false;\n\n  if (handler) {\n    handler(closeEvent);\n  }\n\n  this._pingTimeout && clearTimeout(this._pingTimeout);\n}\n\nfunction onReopen(handler) {\n  this._connected = true;\n\n  this._sendMessage({\n    categoryCode: 'initialize',\n    eventCode: 'checkDappId',\n    connectionId: this._connectionId\n  }); // re-register all accounts to be watched by server upon\n  // re-connection as they don't get transferred over automatically\n  // to the new connection like tx hashes do\n\n\n  this._watchedAccounts.forEach(account => {\n    this._sendMessage({\n      eventCode: 'accountAddress',\n      categoryCode: 'watch',\n      account: {\n        address: account.address\n      }\n    });\n  });\n\n  if (handler) {\n    handler();\n  }\n\n  if (this._socket.ws.on) {\n    // need to re-register ping event since new connection\n    this._socket.ws.on('ping', () => {\n      this._heartbeat && this._heartbeat();\n    });\n\n    this._heartbeat();\n  }\n}\n\nexport default Blocknative;\n"]},"metadata":{},"sourceType":"module"}